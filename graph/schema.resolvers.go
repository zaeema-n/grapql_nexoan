package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"fmt"
	"time"

	"graphql_nexoan/graph/model"

	"github.com/neo4j/neo4j-go-driver/v5/neo4j/dbtype"
)

// Entities is the resolver for the entities field.
// Queries using the filter fields and returns a list of Entity
func (r *queryResolver) Entities(ctx context.Context, filter *model.EntityInput) ([]*model.Entity, error) {
	// Create a session directly to avoid the RunQuery issue
	session := r.DB.NewSession(ctx)
	defer session.Close(ctx)

	// Build the query with proper filtering
	query := `
		MATCH (e)
		WHERE ($id IS NULL OR e.Id = $id)
		  AND ($majorKind IS NULL OR $majorKind IN labels(e))
		  AND ($minorKind IS NULL OR e.MinorKind = $minorKind)
		  AND ($name IS NULL OR e.Name = $name)
		  AND ($created IS NULL OR e.Created = $created)
		  AND ($terminated IS NULL OR e.Terminated = $terminated)
		RETURN e
	`

	// Build parameters map
	params := map[string]interface{}{
		"id":         nilIfEmpty(filter.ID),
		"majorKind":  nilIfEmpty(safeKindMajor(filter)),
		"minorKind":  nilIfEmpty(safeKindMinor(filter)),
		"name":       nilIfEmpty(safeNameValue(filter)),
		"created":    nilIfEmpty(filter.Created),
		"terminated": nilIfEmpty(filter.Terminated),
	}

	result, err := session.Run(ctx, query, params)
	if err != nil {
		return nil, fmt.Errorf("neo4j query failed: %w", err)
	}

	var entities []*model.Entity
	for result.Next(ctx) {
		record := result.Record()
		if len(record.Values) > 0 {
			// Handle Neo4j Node type properly
			if node, ok := record.Values[0].(dbtype.Node); ok {
				// Convert Node properties to map[string]interface{}
				props := make(map[string]interface{})
				for key, value := range node.Props {
					props[key] = value
				}
				// Add the ID from the Node
				//props["Id"] = node.ElementId
				// Add the major kind from the node labels
				if len(node.Labels) > 0 {
					props["MajorKind"] = node.Labels[0]
				}
				entities = append(entities, mapEntityNode(props))
			} else {
				fmt.Printf("Warning: Record is not a Node: %T\n", record.Values[0])
			}
		}
	}

	return entities, nil
}

// Relationships is the resolver for the relationships field.
// Runs for each Entity- to fetch the relationships and related entity ids and returns a list of Relationship
func (r *entityResolver) Relationships(ctx context.Context, obj *model.Entity, relationshipsFilter *model.RelationshipInput) ([]*model.Relationship, error) {
	query := `
		MATCH (e:Entity {id: $entityId})-[rel:RELATES_TO]->(related:Entity)
		WHERE ($relId IS NULL OR rel.id = $relId)
		  AND ($relName IS NULL OR rel.name = $relName)
		  AND ($relatedEntityId IS NULL OR related.id = $relatedEntityId)
		RETURN rel, related
	`

	params := map[string]interface{}{
		"entityId":        obj.ID,
		"relId":           nilIfEmpty(safeRelId(relationshipsFilter)),
		"relName":         nilIfEmpty(safeRelName(relationshipsFilter)),
		"relatedEntityId": nilIfEmpty(safeRelatedEntityId(relationshipsFilter)),
	}

	result, err := r.DB.RunQuery(ctx, query, params)
	if err != nil {
		return nil, fmt.Errorf("neo4j query failed: %w", err)
	}

	var rels []*model.Relationship
	for result.Next(ctx) {
		rec := result.Record()
		relNode := rec.Values[0].(map[string]interface{})
		relatedNode := rec.Values[1].(map[string]interface{})

		rels = append(rels, &model.Relationship{
			ID:        toStringPtr(relNode["id"]),
			Name:      toString(relNode["name"]),
			StartTime: toString(relNode["start_time"]),
			EndTime:   toStringPtr(relNode["end_time"]),
			Direction: toString(relNode["direction"]),
			Entity:    mapEntityNode(relatedNode),
		})
	}
	return rels, nil
}

// Entity is the resolver for the entity field.
// Runs for each Relationship- to fetch the related entity
func (r *relationshipResolver) Entity(ctx context.Context, obj *model.Relationship) (*model.Entity, error) {
	// The entity is already set in Relationships, so just return it
	if obj.Entity != nil {
		return obj.Entity, nil
	}

	// Optional: If you want to fetch from Neo4j in case it's missing
	query := `MATCH (e:Entity {id: $id}) RETURN e`
	params := map[string]interface{}{"id": obj.RelatedEntityID}

	result, err := r.DB.RunQuery(ctx, query, params)
	if err != nil {
		return nil, err
	}
	if result.Next(ctx) {
		record := result.Record()
		node := record.Values[0].(map[string]interface{})
		return mapEntityNode(node), nil
	}
	return nil, nil
}

// Entity returns EntityResolver implementation.
func (r *Resolver) Entity() EntityResolver { return &entityResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Relationship returns RelationshipResolver implementation.
func (r *Resolver) Relationship() RelationshipResolver { return &relationshipResolver{r} }

type entityResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type relationshipResolver struct{ *Resolver }

// ===== HELPERS =====
func nilIfEmpty(s *string) any {
	if s == nil || *s == "" {
		return nil
	}
	return *s
}

// Generic safe field accessor that works with any nested field
func safeField[T any, R any](obj *T, accessor func(*T) R) R {
	if obj == nil {
		var zero R
		return zero
	}
	return accessor(obj)
}

// Safe accessor functions that handle nested nil checks
func safeKindMajor(filter *model.EntityInput) *string {
	if filter == nil || filter.Kind == nil {
		return nil
	}
	return filter.Kind.Major
}

func safeKindMinor(filter *model.EntityInput) *string {
	if filter == nil || filter.Kind == nil {
		return nil
	}
	return filter.Kind.Minor
}

func safeNameValue(filter *model.EntityInput) *string {
	if filter == nil || filter.Name == nil {
		return nil
	}
	return filter.Name.Value
}

func safeNameStartTime(filter *model.EntityInput) *string {
	if filter == nil || filter.Name == nil {
		return nil
	}
	return filter.Name.StartTime
}

func safeNameEndTime(filter *model.EntityInput) *string {
	if filter == nil || filter.Name == nil {
		return nil
	}
	return filter.Name.EndTime
}

func safeRelId(filter *model.RelationshipInput) *string {
	if filter == nil {
		return nil
	}
	return filter.ID
}

func safeRelName(filter *model.RelationshipInput) *string {
	if filter == nil {
		return nil
	}
	return filter.Name
}

func safeRelatedEntityId(filter *model.RelationshipInput) *string {
	if filter == nil {
		return nil
	}
	return filter.RelatedEntityID
}

func toString(v any) string {
	if v == nil {
		return ""
	}
	return fmt.Sprintf("%v", v)
}

func toStringPtr(v any) *string {
	if v == nil {
		return nil
	}
	s := toString(v)
	return &s
}

func toTimePtr(v any) *time.Time {
	if v == nil {
		return nil
	}
	if t, ok := v.(time.Time); ok {
		return &t
	}
	return nil
}

func mapEntityNode(props map[string]interface{}) *model.Entity {
	return &model.Entity{
		ID: toString(props["Id"]),
		Kind: &model.Kind{
			Major: toString(props["MajorKind"]),
			Minor: toString(props["MinorKind"]),
		},
		Name: &model.TimeBasedValue{
			Value:     props["Name"],
			StartTime: toString(props["Created"]),
			EndTime:   nil, // No end time in your data
		},
		Created:    toStringPtr(props["Created"]),
		Terminated: toStringPtr(props["Terminated"]),
	}
}
