package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"fmt"
	"graphql_nexoan/graph/model"
	"time"

	"github.com/neo4j/neo4j-go-driver/v5/neo4j/dbtype"
)

// Relationships is the resolver for the relationships field.
func (r *entityResolver) Relationships(ctx context.Context, obj *model.Entity, relationshipsFilter *model.RelationshipInput) ([]*model.Relationship, error) {
	// Create a session directly to avoid the RunQuery issue
	session := r.DB.NewSession(ctx)
	defer session.Close(ctx)

	query := `
		MATCH (e {Id: $entityId})-[rel]->(related)
		WHERE ($relId IS NULL OR rel.Id = $relId)
		  AND ($relName IS NULL OR type(rel) = $relName)
		  AND ($relatedEntityId IS NULL OR related.Id = $relatedEntityId)
		RETURN rel, related
	`

	params := map[string]interface{}{
		"entityId":        obj.ID,
		"relId":           nilIfEmpty(safeRelId(relationshipsFilter)),
		"relName":         nilIfEmpty(safeRelName(relationshipsFilter)),
		"relatedEntityId": nilIfEmpty(safeRelatedEntityId(relationshipsFilter)),
	}

	fmt.Printf("Running Relationships query: %s\n", query)
	fmt.Printf("With params: %+v\n", params)

	result, err := session.Run(ctx, query, params)
	if err != nil {
		return nil, fmt.Errorf("neo4j query failed: %w", err)
	}

	var rels []*model.Relationship
	for result.Next(ctx) {
		rec := result.Record()

		// Handle Neo4j types properly
		var relNode map[string]interface{}
		var relatedNode map[string]interface{}
		var relName string

		// Extract relationship data
		if rel, ok := rec.Values[0].(dbtype.Relationship); ok {
			relName = rel.Type
			// Convert relationship properties to map
			relNode = make(map[string]interface{})
			for key, value := range rel.Props {
				relNode[key] = value
			}
			// Add the elementId as Id if no Id property exists
			if _, exists := relNode["Id"]; !exists {
				relNode["Id"] = rel.ElementId
			}
		} else {
			return nil, fmt.Errorf("failed to extract relationship from result")
		}

		// Extract related entity data
		if related, ok := rec.Values[1].(dbtype.Node); ok {
			// Convert node properties to map
			relatedNode = make(map[string]interface{})
			for key, value := range related.Props {
				relatedNode[key] = value
			}
			// Add the elementId as Id if no Id property exists
			if _, exists := relatedNode["Id"]; !exists {
				relatedNode["Id"] = related.ElementId
			}
			// Add the major kind from the node labels
			if len(related.Labels) > 0 {
				relatedNode["MajorKind"] = related.Labels[0]
			}
		} else {
			return nil, fmt.Errorf("failed to extract related entity from result")
		}

		rels = append(rels, &model.Relationship{
			ID:              toStringPtr(relNode["Id"]),
			RelatedEntityID: toString(relatedNode["Id"]),
			Name:            relName,
			StartTime:       toString(relNode["Created"]),
			EndTime:         toStringPtr(relNode["Terminated"]),
			Direction:       "OUTGOING", // Since we're going from e to related

			// Instead of setting Entity here, we'll let the Entities resolver handle it
		})
	}
	return rels, nil
}

// Entities is the resolver for the entities field.
// Queries using the filter fields and returns a list of Entity
func (r *queryResolver) Entities(ctx context.Context, entitiesFilter *model.EntityInput) ([]*model.Entity, error) {
	// Create a session directly to avoid the RunQuery issue
	session := r.DB.NewSession(ctx)
	defer session.Close(ctx)

	// Build the query with proper filtering
	query := `
		MATCH (e)
		WHERE ($id IS NULL OR e.Id = $id)
		  AND ($majorKind IS NULL OR $majorKind IN labels(e))
		  AND ($minorKind IS NULL OR e.MinorKind = $minorKind)
		  AND ($name IS NULL OR e.Name = $name)
		  AND ($created IS NULL OR e.Created = $created)
		  AND ($terminated IS NULL OR e.Terminated = $terminated)
		RETURN e
	`

	// Build parameters map
	params := map[string]interface{}{
		"id":         nilIfEmpty(entitiesFilter.ID),
		"majorKind":  nilIfEmpty(safeKindMajor(entitiesFilter)),
		"minorKind":  nilIfEmpty(safeKindMinor(entitiesFilter)),
		"name":       nilIfEmpty(safeNameValue(entitiesFilter)),
		"created":    nilIfEmpty(entitiesFilter.Created),
		"terminated": nilIfEmpty(entitiesFilter.Terminated),
	}

	fmt.Printf("Running Entities query: %s\n", query)
	fmt.Printf("With params: %+v\n", params)

	result, err := session.Run(ctx, query, params)
	if err != nil {
		return nil, fmt.Errorf("neo4j query failed: %w", err)
	}

	var entities []*model.Entity
	for result.Next(ctx) {
		record := result.Record()
		if len(record.Values) > 0 {
			// Handle Neo4j Node type properly
			if node, ok := record.Values[0].(dbtype.Node); ok {
				// Convert Node properties to map[string]interface{}
				props := make(map[string]interface{})
				for key, value := range node.Props {
					props[key] = value
				}
				if len(node.Labels) > 0 {
					props["MajorKind"] = node.Labels[0]
				}
				entities = append(entities, mapEntityNode(props))
			} else {
				fmt.Printf("Warning: Record is not a Node: %T\n", record.Values[0])
			}
		}
	}

	return entities, nil
}

// Entities is the resolver for the entities field.
func (r *relationshipResolver) Entities(ctx context.Context, obj *model.Relationship, entitiesFilter *model.EntityInput) ([]*model.Entity, error) {
	// Create a filter that includes the related entity ID
	entityFilter := &model.EntityInput{
		ID: &obj.RelatedEntityID,
	}

	// If additional filters are provided, merge them
	if entitiesFilter != nil {
		if entitiesFilter.Kind != nil {
			entityFilter.Kind = entitiesFilter.Kind
		}
		if entitiesFilter.Name != nil {
			entityFilter.Name = entitiesFilter.Name
		}
		if entitiesFilter.Created != nil {
			entityFilter.Created = entitiesFilter.Created
		}
		if entitiesFilter.Terminated != nil {
			entityFilter.Terminated = entitiesFilter.Terminated
		}
	}

	fmt.Printf("Running Entities filter: %s\n", *entityFilter.ID)

	// Call the main Entities resolver with the merged filter
	return r.Query().Entities(ctx, entityFilter)
}

// Entity returns EntityResolver implementation.
func (r *Resolver) Entity() EntityResolver { return &entityResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Relationship returns RelationshipResolver implementation.
func (r *Resolver) Relationship() RelationshipResolver { return &relationshipResolver{r} }

type entityResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type relationshipResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.

func nilIfEmpty(s *string) any {
	if s == nil || *s == "" {
		return nil
	}
	return *s
}
func safeField[T any, R any](obj *T, accessor func(*T) R) R {
	if obj == nil {
		var zero R
		return zero
	}
	return accessor(obj)
}
func safeKindMajor(filter *model.EntityInput) *string {
	if filter == nil || filter.Kind == nil {
		return nil
	}
	return filter.Kind.Major
}
func safeKindMinor(filter *model.EntityInput) *string {
	if filter == nil || filter.Kind == nil {
		return nil
	}
	return filter.Kind.Minor
}
func safeNameValue(filter *model.EntityInput) *string {
	if filter == nil || filter.Name == nil {
		return nil
	}
	return filter.Name.Value
}
func safeNameStartTime(filter *model.EntityInput) *string {
	if filter == nil || filter.Name == nil {
		return nil
	}
	return filter.Name.StartTime
}
func safeNameEndTime(filter *model.EntityInput) *string {
	if filter == nil || filter.Name == nil {
		return nil
	}
	return filter.Name.EndTime
}
func safeRelId(filter *model.RelationshipInput) *string {
	if filter == nil {
		return nil
	}
	return filter.ID
}
func safeRelName(filter *model.RelationshipInput) *string {
	if filter == nil {
		return nil
	}
	return filter.Name
}
func safeRelatedEntityId(filter *model.RelationshipInput) *string {
	if filter == nil {
		return nil
	}
	return filter.RelatedEntityID
}
func toString(v any) string {
	if v == nil {
		return ""
	}
	return fmt.Sprintf("%v", v)
}
func toStringPtr(v any) *string {
	if v == nil {
		return nil
	}
	s := toString(v)
	return &s
}
func toTimePtr(v any) *time.Time {
	if v == nil {
		return nil
	}
	if t, ok := v.(time.Time); ok {
		return &t
	}
	return nil
}
func mapEntityNode(props map[string]interface{}) *model.Entity {
	return &model.Entity{
		ID: toString(props["Id"]),
		Kind: &model.Kind{
			Major: toString(props["MajorKind"]),
			Minor: toString(props["MinorKind"]),
		},
		Name: &model.TimeBasedValue{
			Value:     props["Name"],
			StartTime: toString(props["Created"]),
			EndTime:   nil, // No end time in your data
		},
		Created:    toStringPtr(props["Created"]),
		Terminated: toStringPtr(props["Terminated"]),
	}
}
