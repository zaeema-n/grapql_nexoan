package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"fmt"
	"time"

	"graphql_nexoan/graph/model"
)

// Entities is the resolver for the entities field.
// Queries using the filter fields and returns a list of Entity
func (r *queryResolver) Entities(ctx context.Context, filter *model.EntityInput) ([]*model.Entity, error) {
	query := `
		MATCH (e)
		WHERE ($id IS NULL OR e.Id = $id)
		  AND ($kindMajor IS NULL OR e.kind_major = $kindMajor)
		  AND ($kindMinor IS NULL OR e.kind_minor = $kindMinor)
		  AND ($nameValue IS NULL OR e.name_value = $nameValue)
		  AND ($nameStartTime IS NULL OR e.name_start_time = $nameStartTime)
		  AND ($nameEndTime IS NULL OR e.name_end_time = $nameEndTime)
		  AND ($created IS NULL OR e.created = $created)
		  AND ($terminated IS NULL OR e.terminated = $terminated)
		RETURN e
	`

	params := map[string]interface{}{
		"id":            nilIfEmpty(filter.ID),
		"kindMajor":     nilIfEmpty(safeKindMajor(filter)),
		"kindMinor":     nilIfEmpty(safeKindMinor(filter)),
		"nameValue":     nilIfEmpty(safeNameValue(filter)),
		"nameStartTime": nilIfEmpty(safeNameStartTime(filter)),
		"nameEndTime":   nilIfEmpty(safeNameEndTime(filter)),
		"created":       nilIfEmpty(filter.Created),
		"terminated":    nilIfEmpty(filter.Terminated),
	}

	result, err := r.DB.RunQuery(ctx, query, params)
	if err != nil {
		return nil, fmt.Errorf("neo4j query failed: %w", err)
	}

	var entities []*model.Entity
	for result.Next(ctx) {
		record := result.Record()
		node := record.Values[0].(map[string]interface{})
		entities = append(entities, mapEntityNode(node))
	}
	return entities, nil
}

// Relationships is the resolver for the relationships field.
// Runs for each Entity- to fetch the relationships and related entity ids and returns a list of Relationship
func (r *entityResolver) Relationships(ctx context.Context, obj *model.Entity, relationshipsFilter *model.RelationshipInput) ([]*model.Relationship, error) {
	query := `
		MATCH (e:Entity {id: $entityId})-[rel:RELATES_TO]->(related:Entity)
		WHERE ($relId IS NULL OR rel.id = $relId)
		  AND ($relName IS NULL OR rel.name = $relName)
		  AND ($relatedEntityId IS NULL OR related.id = $relatedEntityId)
		RETURN rel, related
	`

	params := map[string]interface{}{
		"entityId":        obj.ID,
		"relId":           nilIfEmpty(safeRelId(relationshipsFilter)),
		"relName":         nilIfEmpty(safeRelName(relationshipsFilter)),
		"relatedEntityId": nilIfEmpty(safeRelatedEntityId(relationshipsFilter)),
	}

	result, err := r.DB.RunQuery(ctx, query, params)
	if err != nil {
		return nil, fmt.Errorf("neo4j query failed: %w", err)
	}

	var rels []*model.Relationship
	for result.Next(ctx) {
		rec := result.Record()
		relNode := rec.Values[0].(map[string]interface{})
		relatedNode := rec.Values[1].(map[string]interface{})

		rels = append(rels, &model.Relationship{
			ID:        toStringPtr(relNode["id"]),
			Name:      toString(relNode["name"]),
			StartTime: toString(relNode["start_time"]),
			EndTime:   toStringPtr(relNode["end_time"]),
			Direction: toString(relNode["direction"]),
			Entity:    mapEntityNode(relatedNode),
		})
	}
	return rels, nil
}

// Entity is the resolver for the entity field.
// Runs for each Relationship- to fetch the related entity
func (r *relationshipResolver) Entity(ctx context.Context, obj *model.Relationship) (*model.Entity, error) {
	// The entity is already set in Relationships, so just return it
	if obj.Entity != nil {
		return obj.Entity, nil
	}

	// Optional: If you want to fetch from Neo4j in case it's missing
	query := `MATCH (e:Entity {id: $id}) RETURN e`
	params := map[string]interface{}{"id": obj.RelatedEntityID}

	result, err := r.DB.RunQuery(ctx, query, params)
	if err != nil {
		return nil, err
	}
	if result.Next(ctx) {
		record := result.Record()
		node := record.Values[0].(map[string]interface{})
		return mapEntityNode(node), nil
	}
	return nil, nil
}

// Entity returns EntityResolver implementation.
func (r *Resolver) Entity() EntityResolver { return &entityResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Relationship returns RelationshipResolver implementation.
func (r *Resolver) Relationship() RelationshipResolver { return &relationshipResolver{r} }

type entityResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type relationshipResolver struct{ *Resolver }

// ===== HELPERS =====
func nilIfEmpty(s *string) any {
	if s == nil || *s == "" {
		return nil
	}
	return *s
}

// Generic safe field accessor that works with any nested field
func safeField[T any, R any](obj *T, accessor func(*T) R) R {
	if obj == nil {
		var zero R
		return zero
	}
	return accessor(obj)
}

// Safe accessor functions that handle nested nil checks
func safeKindMajor(filter *model.EntityInput) *string {
	if filter == nil || filter.Kind == nil {
		return nil
	}
	return filter.Kind.Major
}

func safeKindMinor(filter *model.EntityInput) *string {
	if filter == nil || filter.Kind == nil {
		return nil
	}
	return filter.Kind.Minor
}

func safeNameValue(filter *model.EntityInput) *string {
	if filter == nil || filter.Name == nil {
		return nil
	}
	return filter.Name.Value
}

func safeNameStartTime(filter *model.EntityInput) *string {
	if filter == nil || filter.Name == nil {
		return nil
	}
	return filter.Name.StartTime
}

func safeNameEndTime(filter *model.EntityInput) *string {
	if filter == nil || filter.Name == nil {
		return nil
	}
	return filter.Name.EndTime
}

func safeRelId(filter *model.RelationshipInput) *string {
	if filter == nil {
		return nil
	}
	return filter.ID
}

func safeRelName(filter *model.RelationshipInput) *string {
	if filter == nil {
		return nil
	}
	return filter.Name
}

func safeRelatedEntityId(filter *model.RelationshipInput) *string {
	if filter == nil {
		return nil
	}
	return filter.RelatedEntityID
}

func toString(v any) string {
	if v == nil {
		return ""
	}
	return fmt.Sprintf("%v", v)
}

func toStringPtr(v any) *string {
	if v == nil {
		return nil
	}
	s := toString(v)
	return &s
}

func toTimePtr(v any) *time.Time {
	if v == nil {
		return nil
	}
	if t, ok := v.(time.Time); ok {
		return &t
	}
	return nil
}

func mapEntityNode(props map[string]interface{}) *model.Entity {
	return &model.Entity{
		ID: toString(props["id"]),
		Kind: &model.Kind{
			Major: toString(props["kind_major"]),
			Minor: toString(props["kind_minor"]),
		},
		Name: &model.TimeBasedValue{
			Value:     props["name_value"],
			StartTime: toString(props["name_start_time"]),
			EndTime:   toStringPtr(props["name_end_time"]),
		},
		Created:    toStringPtr(props["created"]),
		Terminated: toStringPtr(props["terminated"]),
	}
}
